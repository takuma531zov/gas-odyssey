---
status: entry
title: MCP内部構造とアーキテクチャ詳解 - プロトコル設計から理解する新しいAI連携の仕組み
tags:
  - MCP
  - アーキテクチャ
  - プロトコル
  - セキュリティ
Created: <% tp.file.creation_date("YYYY-MM-DD HH:mm:ss") %>
Updated: <% tp.file.last_modified_date("YYYY-MM-DD HH:mm:ss") %>
author: S-Tak
read_time: "3"
---

## 〜アーキテクチャから理解するMCPの設計思想〜

## はじめに

前回の記事「[今さら聞けない「MCP」とは？超わかりやすく解説](リンク)」では、
MCPの概要と活用メリットについて解説しました。

本記事では、その**技術的深層**に焦点を当て、
MCPがどのような**アーキテクチャ・プロトコル設計**によって実現されているのかを詳しく解説します。

具体的には

- **なぜこのアーキテクチャなのか**（設計原則と背景）
- **プロトコル層でどう通信しているのか**（JSON-RPC 2.0の実例）
- **セキュリティをどう担保しているのか**（脅威シナリオと対策）
- **従来のAPI連携と何が違うのか**（比較と優位性）

これらの視点から、MCPの設計思想を深く理解していきます。

---

## 対象読者

- MCPの仕組みを技術的観点から理解したいエンジニア
- プロトコル設計やアーキテクチャパターンに興味がある方
- MCPサーバの実装を検討している方
- AI連携システムの設計・選定に関わる方

**前提知識**：
- 基本的なHTTP/APIの知識
- JSONフォーマットの理解
- プロセス間通信の基礎概念

プロトコル設計が初めての方でも理解できるよう、具体例を交えて解説します。

---

## MCPのアーキテクチャ全体像

### 3層構造の設計

MCPは以下の3つのコンポーネントで構成されています。
![](_MCP_-1767229065578.png)
#### ホスト（Host）
**役割**：全体の司令塔

- ユーザーとの対話窓口
- 複数のクライアントを生成・管理
- セッション全体のライフサイクル管理
- LLMとの統合

**具体例**：Claude Desktop、Cursor、GitHub Copilot

#### クライアント（Client）
**役割**：特定サーバとの1対1セッションを担当

- ホストの指示を受けてサーバと通信
- サーバとの機能ネゴシエーション
- リクエスト・レスポンスの橋渡し

**重要な特徴**
- 1つのクライアントは**1つのサーバとのみ通信**
- クライアント同士は直接通信しない（情報漏洩防止）

#### サーバ（Server）
**役割**：データや機能を提供する実行主体

- 外部システムとの連携窓口
- リソース・プロンプト・ツールの提供
- 単一責務に特化した設計

**具体例**：Filesystem、GitHub、Slack、PostgreSQL

---

## 3層構造の設計思想 - 4つの原則

この3層構造は、以下の4つの設計原則に基づいています。

### ① サーバの簡易構築

**原則**：サーバは単一責務に特化し、複雑性を排除

**従来の問題**：
- モノリシックな統合サーバ
  → 複数機能を1つのサーバに実装
  → 依存関係が複雑化
  → 保守コストが増大

**MCPの解決策**：
- **GitHubサーバ** → GitHub連携のみに特化（単一責務）
- **Slackサーバ** → Slack連携のみに特化（単一責務）
- **Databaseサーバ** → DB連携のみに特化（単一責務）

**効果**：
- 各サーバは**1つの外部システムとの連携のみ**を担当
- ホストが全体統制を担うことで、サーバの負荷を軽減
- 実装・テスト・保守が容易

### ② 高いコンポーザビリティ（組み合わせ可能性）

**原則**：独立したモジュールとして、自由に組み合わせ可能

**Claude Desktopの例**
- Client #1 → GitHub Server
- Client #2 → Slack Server
- Client #3 → Database Server

**Cursorの例**
- Client #1 → GitHub Server（同じサーバを再利用）
- Client #2 → Filesystem Server

```
[図解イメージ]
[GitHub MCP Server 実装]
        ▲
        │（同じ仕様・同じコード）
        │
 ┌──────┴───────────┐
 │             　　　│
Claude Desktop   Cursor
Client #1        Client #1

```

**メリット**：
- 同じMCPサーバを**複数のホストで共有**できる
- 新しいサーバを追加しても、既存サーバに影響なし
- 将来の拡張や差し替えが容易

### ③ 厳密なセキュリティ境界

**原則**：サーバ間は完全に分離し、情報漏洩を防ぐ

**危険なアーキテクチャ（サーバ間で直接通信）**
```
[ Server 1 ] ←────────→ [ Server 2 ]
```

- サーバ同士が直接通信
　**問題点**
	- Server1 のデータが Server2 に漏洩する可能性
	- 権限境界が曖昧になる
	- 通信の監査・制御が困難

**MCPのアーキテクチャ（ホスト経由のみ）**
```
[ Server 1 ] ──→
                 [ Host ]
[ Server 2 ] ──→
```

- **全ての通信はHostを経由**
- **ホストが情報の流れを一元管理

**セキュリティ上の重要性**：
- サーバは**必要最小限の情報のみ**受け取る
- セッション間の直接通信は不可能
- ホストを介することで、**監査・制御が可能**

### ④ 段階的機能拡張

**原則**：基本機能を最小限に留め、必要に応じて拡張

**機能ネゴシエーション（すり合わせ）の仕組み**

1. **機能の提示**
   - Client
	「私は **A・B・C** の機能をサポートしています」
   - Server
	「私は **B・C・D** の機能をサポートしています」

2. **共通部分の有効化**
   - このセッションで使用可能なのは
    👉 **B・C のみ**
   - 未対応機能（A・D）は自動的に無効化

3. **独立した進化**
   - Client が新機能 **E** を追加しても...
	《Server に変更は不要》
   - Server が新機能 **F** を追加しても...
    《既存 Client はそのまま動作》
　
**メリット**：
- **古いクライアント／サーバとの互換性を維持**できる
- 新機能を**破壊的変更なしで段階的に追加**できる
- 不要な機能を相手に**強制しない設計**
- クライアント・サーバが**独立して進化可能**

---

## JSON-RPC 2.0 - MCPの通信フォーマット

MCPは**JSON-RPC 2.0**をメッセージフォーマットとして採用しています。

### なぜJSON-RPC 2.0なのか

**選定理由**：
1. **シンプル**：JSONベースで読みやすい
2. **ステートレス**：セッション管理が簡潔
3. **双方向通信**：クライアント・サーバ両方からリクエスト可能
4. **言語非依存**：あらゆる言語で実装可能

### メッセージの3つの種類

#### ① Requests（リクエスト）

**用途**：相手に処理を要求し、結果を待つ

**フォーマット**：
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "create_issue",
    "arguments": {
      "title": "Bug: Login error",
      "body": "Users cannot login"
    }
  }
}
```

**実例：ツール呼び出し**

Client → Server: tools/call リクエスト
```json
{
  "jsonrpc": "2.0",
  "id": 123,
  "method": "tools/call",
  "params": {
    "name": "github_create_issue",
    "arguments": {
      "repo": "my-repo",
      "title": "Feature request",
      "body": "Add dark mode"
    }
  }
}
```

Server → Client: レスポンス
```json
{
  "jsonrpc": "2.0",
  "id": 123,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Issue #42 created successfully"
      }
    ],
    "isError": false
  }
}
```

**ポイント**：
- `id` フィールドでリクエストとレスポンスを紐付け
- `method` で呼び出す処理を指定
- `params` で引数を渡す

#### ② Responses（レスポンス）

**用途**：リクエストに対する結果またはエラーを返す

**成功時のフォーマット**：
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Processing completed"
      }
    ]
  }
}
```

**エラー時のフォーマット**：
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Invalid params",
    "data": {
      "detail": "Required field 'title' is missing"
    }
  }
}
```

**エラーコード（JSON-RPC 2.0標準）**

| コード    | 意味               | 説明         |
| ------ | ---------------- | ---------- |
| -32700 | Parse error      | JSON解析エラー  |
| -32600 | Invalid Request  | リクエストが不正   |
| -32601 | Method not found | メソッドが存在しない |
| -32602 | Invalid params   | パラメータが不正   |
| -32603 | Internal error   | サーバ内部エラー   |

#### ③ Notifications（通知）

**用途**：相手に情報を伝えるが、応答は期待しない

**フォーマット**：
```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "file:///project/README.md"
  }
}
```

**実例：リソース更新通知**

Server → Client: リソースが更新されたことを通知
```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "postgres://database/customers/table"
  }
}
```

**ポイント**：
- `id` フィールドが**ない**（応答不要）
- イベント駆動の仕組みに最適
- リアルタイム性が必要な更新通知に使用

---

## 実際の通信フロー - 機能ネゴシエーションとツール実行

MCPセッションは以下のシーケンスで確立されます。

### セッション初期化フロー

**ステップ1：クライアント生成**
- ホストが新しいクライアントを生成・初期化

**ステップ2：initialize リクエスト**
- クライアントがサーバに機能を指定してセッションを初期化
- クライアントが対応可能な機能（roots, samplingなど）を宣言

**ステップ3：機能確認・レスポンス**
- サーバが自身の対応機能（resources, toolsなど）を返す

**ステップ4：共通機能で有効化**
- クライアントとサーバの共通機能のみを有効化
- 例：roots, sampling, resources, tools が利用可能に

**ステップ5：セッション確立**
- ネゴシエーション完了、通信開始

### 実際のメッセージ例

**① クライアント → サーバ：初期化リクエスト**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "roots": {
        "listChanged": true
      },
      "sampling": {}
    },
    "clientInfo": {
      "name": "Claude Desktop",
      "version": "1.0.0"
    }
  }
}
```

**② サーバ → クライアント：機能レスポンス**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "resources": {
        "subscribe": true,
        "listChanged": true
      },
      "tools": {
        "listChanged": false
      },
      "prompts": {
        "listChanged": false
      }
    },
    "serverInfo": {
      "name": "filesystem-server",
      "version": "0.1.0"
    }
  }
}
```

**③ ネゴシエーション結果**

このセッションで利用可能な機能：
- ✅ **Roots**（クライアント提供）：サーバがクライアントにルート情報を問い合わせ可能
- ✅ **Sampling**（クライアント提供）：サーバがLLM呼び出しを依頼可能
- ✅ **Resources**（サーバ提供）：クライアントがリソースを取得可能
- ✅ **Tools**（サーバ提供）：クライアントがツールを実行可能
- ✅ **Prompts**（サーバ提供）：クライアントがプロンプトを取得可能

### ツール実行のフロー

機能ネゴシエーション後の実際のやり取り例：

**ステップ1：ツール一覧取得**
- ホスト → クライアント → サーバ：`tools/list` リクエスト
- サーバ → クライアント → ホスト：利用可能なツールのリスト（例：read_file, write_file, list_directory）

**ステップ2：LLMが判断**
- ホスト内のLLMが「read_fileを呼ぶべき」と判断

**ステップ3：ツール実行依頼**
- ホスト → クライアント → サーバ：`tools/call` リクエスト
  - name: "read_file"
  - arguments: { path: "README.md" }

**ステップ4：ファイル読み込み実行**
- サーバがファイルを読み込み
- サーバ → クライアント → ホスト：ファイル内容を返却

**実際のメッセージ**：

```json
// tools/list リクエスト
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/list"
}

// tools/list レスポンス
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "tools": [
      {
        "name": "read_file",
        "description": "Read contents of a file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the file"
            }
          },
          "required": ["path"]
        }
      }
    ]
  }
}

// tools/call リクエスト
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "tools/call",
  "params": {
    "name": "read_file",
    "arguments": {
      "path": "/project/README.md"
    }
  }
}

// tools/call レスポンス
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "# My Project\n\nThis is a sample project..."
      }
    ],
    "isError": false
  }
}
```

---

## トランスポート層 - stdioとHTTP

JSON-RPCメッセージを運ぶ「通信経路」として、MCPは2つのトランスポートをサポートしています。

### stdio（標準入出力）- ローカルMCPサーバ

**仕組み**：
- **Host/Client**がサーバプロセスをサブプロセスとして起動
- **stdin**（標準入力） ← JSON-RPCリクエストを送信
- **stdout**（標準出力） → JSON-RPCレスポンスを受信
- **stderr**（標準エラー出力） → ログ/エラーを受信

**特徴**：
- サーバを**サブプロセス**として起動
- クライアントとサーバは**同一マシン上**で動作
- `stdin` でリクエスト送信、`stdout` でレスポンス受信
- `stderr` でログ・エラー出力を分離

**メリット**：
- セットアップが簡単（追加のサーバ起動不要）
- ローカル環境で完結（ネットワーク不要）
- デバッグしやすい（stderr でログ確認）

**デメリット**：
- リモートからアクセスできない
- 同一マシン上でのみ動作

### Streamable HTTP - リモートMCPサーバ

**仕組み**：
- **Host/Client**と**Remote Server**がHTTP/HTTPSで通信
- HTTP POST /message にJSON-RPCメッセージを送信
- **X-Session-ID**ヘッダーでセッションを管理
- ステートフルなやり取りを実現

**特徴**：
- HTTP/HTTPSで**ネットワーク越し**に通信
- すべてのリクエストに**セッションID**をヘッダーで付与（X-Session-ID）
- ステートフルなやり取りを実現

**メリット**：
- リモートからアクセス可能
- クラウド環境に最適
- スケーラブル（複数クライアントから接続可能）

**デメリット**：
- HTTPサーバの構築が必要
- ネットワーク遅延が発生

### 使い分けの基準

| 用途 | トランスポート | 理由 |
|------|---------------|------|
| ローカルファイル操作 | stdio | 同一マシン内で完結 |
| 個人開発環境 | stdio | セットアップが簡単 |
| 社内データベース連携 | HTTP | ネットワーク越しにアクセス |
| クラウドAPI連携 | HTTP | リモートサービスとの統合 |
| 複数ユーザーで共有 | HTTP | 1つのサーバを複数から利用 |

---

## 従来のAPI連携との比較

MCPと従来のAPI連携アプローチの違いを整理します。

### 従来のアプローチ：個別統合

**構造**：
- AIアプリA（Claude Desktop）が個別に各サービスと連携
  - GitHub API専用コード
  - Slack API専用コード
  - Database専用コード
  - Custom API専用コード

**問題点**：
- ❌ アプリごとに全て実装し直す必要がある
- ❌ 連携方法がバラバラ
- ❌ 保守コストが高い
- ❌ 他のAIアプリで再利用できない

### MCPのアプローチ：標準化された統合

**構造**：
- **上層**：AIアプリA（Claude Desktop）、AIアプリB（Cursor）、AIアプリC（Copilot）
- **中間**：MCP標準プロトコル（共通仕様）
- **下層**：GitHub MCPサーバ、Slack MCPサーバ、Database MCPサーバ

**メリット**：
- ✅ 一度実装すれば、複数のAIアプリで使える
- ✅ 統一されたプロトコル
- ✅ 保守が容易
- ✅ エコシステムの恩恵を受けられる


### 比較表

| 項目 | 従来のAPI連携 | MCP |
|------|--------------|-----|
| **実装の再利用性** | ❌ AIアプリごとに実装 | ✅ 1つの実装を全てで共有 |
| **プロトコル** | 各AIアプリ独自 | JSON-RPC 2.0（統一） |
| **保守コスト** | 高い（複数の実装を維持） | 低い（1つの実装のみ） |
| **新サービス追加時** | 全AIアプリで実装し直し | MCPサーバを1つ追加するだけ |
| **セキュリティ** | 実装ごとに確認が必要 | 標準化されたセキュリティモデル |
| **機能の発見** | ドキュメントに依存 | 機能ネゴシエーションで自動 |
| **エコシステム** | 個別 | コミュニティ全体で共有 |

### Function Calling との関係

**Function Calling**：
- LLMが「どの関数を呼ぶべきか」を判断する仕組み
- **関数の定義と実行**に焦点

**MCP**：
- AIアプリと外部システムを**標準的に繋ぐ**仕組み
- **プロトコル・アーキテクチャ全体**に焦点

**つまり**：
- **Function Calling** = **何を実行するか**の判断（LLM層）
- **MCP** = **どう実行するか**の標準化（通信層）

両者は**補完関係**にあり、Function CallingがツールCallの判断を行い、MCPがその実行を標準化されたプロトコルで実現します。

---

## まとめ

本記事では、MCPの内部構造とアーキテクチャを詳しく解説しました。

### 重要なポイント

**① 3層アーキテクチャの設計原則**
- ホスト・クライアント・サーバの明確な責務分離
- 単一責務・高い組み合わせ可能性・厳密なセキュリティ境界
- 段階的機能拡張による柔軟性

**② JSON-RPC 2.0による標準化**
- シンプルで言語非依存なメッセージフォーマット
- Requests・Responses・Notificationsの3種類
- 機能ネゴシエーションによる互換性確保

**③ セキュリティ設計の徹底**
- サーバ間の直接通信を禁止
- ホスト経由による情報フロー制御
- 最小権限の原則と入力検証

**④ 従来のAPI連携との違い**
- 一度の実装で複数のAIアプリに対応
- 標準化されたプロトコルによる保守性向上
- エコシステム全体での恩恵

### MCPの本質的価値

MCPは単なる「便利なツール」ではなく、

**「AIアプリケーションと外部システムを繋ぐ標準プロトコル」**

として設計されています。

この標準化により：

✅ **開発者**：一度実装すれば、複数のAIツールで使える
✅ **ユーザー**：好きなAIツールを選びながら、同じ連携機能を使える
✅ **エコシステム**：コミュニティ全体でMCPサーバを共有・改善できる

### 次のステップ

アーキテクチャを理解したら、次は実装に進みましょう：

- 公式SDK（TypeScript/Python）のチュートリアル
- リファレンスサーバのコードリーディング
- カスタムMCPサーバの実装

**apsis**では、MCP実装ガイドやユースケース解説も随時公開予定です。

👉 https://apsis-dx.com

---

本記事が、MCPの設計思想と技術的背景を理解する助けになれば幸いです。

AIアプリケーションの連携基盤として、MCPがどのように設計されているかを知ることで、
より効果的な活用や、独自のMCPサーバ実装につながることを願っています。
